
# std
import re
import textwrap as txw
from pathlib import Path

# third-party
import pytest

# local
import docsplice as doc


# ---------------------------------------------------------------------------- #
# Example from README

RGX_EXAMPLE = re.compile(r'(?s)\n\s*```python\s+(.+?)```')

HERE = Path(__file__)
README = HERE.parent.parent.absolute() / 'README.md'


def get_readme_examples(filename=README):
    # sourcery skip: hoist-statement-from-loop
    readme = Path(filename).read_text()
    for match in RGX_EXAMPLE.finditer(readme):
        yield match[1]


@pytest.fixture
def readme_example():
    code = next(get_readme_examples())
    locals_ = {}
    exec(code, None, locals_)
    return locals_['combined']


def test_readme_example(readme_example):
    expected = txw.dedent(
    """
    Some profound computation. Parameter descriptions follow:

    Parameters
    ----------
    a : int
        The number.
    n : int, optional
        Another number! By default 7.
    """
    )
    assert readme_example.__doc__ == expected
    


# ---------------------------------------------------------------------------- #


def subroutine1(a, b):
    """
    This is just a test. The next paragraph is just psuedo philosophic giberish
    for the sake of example.

    As any dedicated reader can clearly see, the Ideal of practical reason is a
    representation of, as far as I know, the things in themselves; as I have
    shown elsewhere, the phenomena should only be used as a canon for our
    understanding. The paralogisms of practical reason are what first give rise
    to the architectonic of practical reason. As will easily be shown in the
    next section, reason would thereby be made to contradict, in view of these
    considerations, the Ideal of practical reason, yet the manifold depends on
    the phenomena. Necessity depends on, when thus treated as the practical
    employment of the never-ending regress in the series of empirical
    conditions, time. Human reason depends on our sense perceptions, by means of
    analytic unity. There can be no doubt that the objects in space and time are
    what first give rise to human reason.

    Parameters
    ----------
    a : int
        "God made the integers ..."
            --- Leopold Kronecker
    b : ArcheType
        Insert some profound description here.

    Returns
    -------
    YourReturnType
        Some description


    Examples
    --------
    >>> sub_routine1(1)

    Raises
    ------
    Exception
        If something went terribly wrong.

    References
    ----------
    .. [1] Eric Temple Bell, 1986. "Men of Mathematics", Simon and Schuster, 
       New York. p. 477

    Notes
    -----
    Extended summary generated by the KantGenerator from 
    `Dive Into Python: Chapter 9 
    https://python.developpez.com/cours/DiveIntoPython/php/endiveintopython/xml_processing/`_.
    """


@doc.splice(subroutine1, )
def subroutine2(a, b):
    """
    This is another subroutine.  It uses the same parameter `a` as
    :func:`subroutine1`.


    """

# def test_readme_example():


# ---------------------------------------------------------------------------- #
# Stripped down examples from actual usage
#
# recipes.string.brackets
# -----------------------

class Brackets:
    """
    Class representing a pair of brackets
    """

    def __init__(self, pair):
        """
        Object representing a pair of brackets

        Parameters
        ----------
        pair : str or tuple of str
            Characters or strings for opening and closing bracket. Must have
            length of 2.
        """

    def match(self, string, indexed=True, must_close=False):
        """
        Summary omitted for brevity.

        Parameters
        ----------
        string : str
            The string to parse.
        return_index : bool
            Whether to return the indices where the brackets where found.
        must_close : int
            Controls behaviour on unmatched bracket pairs. If 1 or True a
            ValueError will be raised, if 0 or False `None` will be returned
            even if there is an opening bracket.  If -1, partial matches are
            allowed and the partial string beginning one character after the
            opening bracket will be returned. In this case, if `return_index` is
            True, the index of the closing brace position will take the value
            None.

        Examples
        --------
        >>> s = 'def sample(args=(), **kws):'
        >>> r, (i, j) = Brackets('()').match(s)
        ('args=(), **kws' , (10, 25)) 
        >>> r == s[i+1:j]
        True

        Returns
        -------
        match : str or None 
            The enclosed str index: tuple or None (start, end) indices of the
            actual brackets that were matched

        Raises
        ------
        ValueError if `must_close` is True and there is no matched closing
        bracket
        """


@doc.splice(Brackets.match,  {'Parameters[pair] as brackets': Brackets})
def match(string, brackets, indexed=True, must_close=False):
    pass

#
# recipes.string.brackets
# -----------------------
